package be.ac.ulg.montefiore.run.jahmm.toolbox;

import java.util.ArrayList;
import java.util.List;

import be.ac.ulg.montefiore.run.jahmm.*;


/**
 * Generates sequences of markovian observations given a HMM.
 */
public class MarkovGenerator<O extends Observation>
{	
	private final Hmm<O> hmm;
	private int stateNb;
	
	
	/**
	 * Initializes a Markovian generator.
	 *
	 * @param hmm An Hidden Markov Model that perfectly models the sequences
	 *            generated by this object.
	 */
	public MarkovGenerator(Hmm<O> hmm)
	{
		if (hmm == null)
			throw new IllegalArgumentException("Invalid null HMM");
		
		this.hmm = hmm;
		newSequence();
	}
	
	
	/**
	 * Generates a new (pseudo) random observation.
	 *
	 * @return The generated observation.
	 */
	public O observation()
	{	
		O o = hmm.getOpdf(stateNb).generate();
		double rand = Math.random();
		
		for (int j = 0; j < hmm.nbStates()-1; j++)
			if ((rand -= hmm.getAij(stateNb, j)) < 0) {
				stateNb = j;
				return o;
			}
		
		stateNb = hmm.nbStates() - 1;
		return o;
	}
	
	
	/**
	 * Generates a new (pseudo) random observation sequence and start
	 * a new one.
	 * 
	 * @param length The length of the sequence.
	 * @return An observation sequence.
	 */
	public List<O> observationSequence(int length)
	{	
		if (length <= 0)
			throw new IllegalArgumentException("Positive length required");
		
		ArrayList<O> sequence = new ArrayList<O>();		
		while (length-- > 0)
			sequence.add(observation());
		newSequence();
		
		return sequence;
	}
	
	
	/**
	 * Finds a new state according to the initial (pi) probabilities of each
	 * state.
	 */
	public void newSequence()
	{	
		double rand = Math.random(), current = 0.;
		
		for (int i = 0; i < hmm.nbStates() - 1; i++) {
			current += hmm.getPi(i);
			
			if (current > rand) {
				stateNb = i;
				return;
			}
		}
		
		stateNb = hmm.nbStates() - 1;
	}
	
	
	/**
	 * Returns the state number of the current state.
	 *
	 * @return A state number.
	 */
	public int stateNb()
	{
		return stateNb;
	}
}
